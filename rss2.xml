<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>绝剑阁</title>
    <link>https://cjliblog.top/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/9a30667a06f9e54b4502c81e69456aa3</url>
      <title>绝剑阁</title>
      <link>https://cjliblog.top/</link>
    </image>
    
    <atom:link href="https://cjliblog.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>银屏之下，龙游四海。</description>
    <pubDate>Thu, 03 Apr 2025 11:56:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>6.四月</title>
      <link>https://cjliblog.top/2025/04/03/6.%E5%9B%9B%E6%9C%88/</link>
      <guid>https://cjliblog.top/2025/04/03/6.%E5%9B%9B%E6%9C%88/</guid>
      <pubDate>Thu, 03 Apr 2025 11:56:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-select-poll-epoll&quot;&gt;&lt;a href=&quot;#1-select-poll-epoll&quot; class=&quot;headerlink&quot; title=&quot;1.select&amp;#x2F;poll&amp;#x2F;epoll&quot;&gt;&lt;/a&gt;1.select&amp;#x2F;poll&amp;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-select-poll-epoll"><a href="#1-select-poll-epoll" class="headerlink" title="1.select&#x2F;poll&#x2F;epoll"></a>1.select&#x2F;poll&#x2F;epoll</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>定位为是linux上的一个api。当然其实各个操作系统上都有实现这样一个“socket”，但是我们一说到操作系统默认就是linux。理解这一点非常重要。</p><p>socket翻译过来叫插座，调用它可以创建一个网络连接。所以不如叫他《网络编程》。linux中一切皆文件，所以socket自然就是文件。linux有个概念叫fd（windows里叫句柄，是一个指针），也就是文件描述符，这就是文件的唯一id（直接叫他索引）。准确来说socket是通过linux内核暴露的api来操作linux内核。如果感到抽象，不妨想想前端调用后端的api接口，所谓“内核”有时候听起来很高级，其实只不过就是个相对于调用方的“后端”罢了，所以我归纳为内核就是一个提供了调用接口的功能实现者实体。</p><p>最常见来说，网络请求的协议是HTTP。那么HTTP只不过是对TCP的封装，本质上的特性都应该在传输层的TCP来看。为什么提到网络就这么喜欢说TCP？你就当他是个坤哥，后面可能有很多协议，但是本质上只是在模仿他，根本无法撼动“网络协议之父”这种经典的存在。所以在日常也要默认网络通信协议就是TCP。</p><p>复习一下，我们认为OS默认是linux，网络协议默认是TCP。再补充一点，从数据库层面看，索引默认是id。</p><p>确定一个通信实体（或说是进程？对我来说，实体、对象就是“东西”这个词的文雅说法罢了），需要IP和端口号，也就是我们常见的http:&#x2F;&#x2F;后面带的一串东西。比如<a href="http://127.0.0.1:7890就是我们常见的某串东西（doge）。再进一步说。网卡和IP地址是一对一的关系。而端口号是一个IP复用的序列号（对于这种类似于id的唯一标识，我想称他序列号），因为他就默认是1～65535。对的，我们完全可以用常见的编程语言go来说，这个socket其实就类似于NewSocket()这样一个函数，返回了一个网络连接实体，那么他叫socket。怎么去确定另一方通信实体呢？就是一个函数叫做bind()。">http://127.0.0.1:7890就是我们常见的某串东西（doge）。再进一步说。网卡和IP地址是一对一的关系。而端口号是一个IP复用的序列号（对于这种类似于id的唯一标识，我想称他序列号），因为他就默认是1～65535。对的，我们完全可以用常见的编程语言go来说，这个socket其实就类似于NewSocket()这样一个函数，返回了一个网络连接实体，那么他叫socket。怎么去确定另一方通信实体呢？就是一个函数叫做bind()。</a></p><p>更进一步，listen()可以进行监听，accept()可以获取监听中的连接（没错，监听是拿不到连接的，还得主动去接收一下，就类似你收音机信号有了，但是你还得主动去搜查哪些频道是有节目的）。</p><p>上面说的是server是接收方，但是client怎么去发起连接？调用connect()即可。当然也需要提供服务端的IP和端口号来确定一个通信的目标实体。</p><p>这非常像网关的服务注册。对于client来说，我要注册我自己，我得提供我的IP和端口给对方，然后我也要确定对方的IP和端口才能告诉他我要注册。</p><p>后续就是TCP的三次握手了。简单来说我们server有两个队列，一个队列还没三次握手，一个已经三次握手。而后者中的连接实体才是可以通过accept()获取了。</p><p>还需要注意监听socket和传输数据的socket是两个实体。当连接建立，就可以用 <code>read()</code> 和 <code>write()</code> 函数来读写数据。</p><h3 id="什么是I-O？"><a href="#什么是I-O？" class="headerlink" title="什么是I&#x2F;O？"></a>什么是I&#x2F;O？</h3><p>os中跨内核态与用户态的读写操作。可以直接简称为读写，是操作文件的input和output。</p><h3 id="如何区分多个client连接？"><a href="#如何区分多个client连接？" class="headerlink" title="如何区分多个client连接？"></a>如何区分多个client连接？</h3><p>现在我们有一个发送队列和接收队列。他是一直阻塞的，也就是说我发送了，另一方不去拿走（消费），他就残留在队列里。</p><p>TCP连接是可以被确定的，就像平面上确定了两个点就可以连出一条线段。我们通过画图展示可爱的四元组。</p><p><img src="/2025/04/03/6/Users\11953\AppData\Roaming\Typora\typora-user-images\image-20250402053223047.png" alt="image-20250402053223047"></p><p>然后我们就会发现连接数量这个实体，在os里是一个文件。进一步说，连接是占用存储空间的。这就联想到我们的并发问题。也就是说，连接过多了，不就是OOM问题了吗？现在突然就想通了。因此，为了解决这种愚蠢的连接结构带来的愚蠢性能，我们需要采取一些智慧的措施。</p><p>首先想到我们可以多个进程，父进程负责监听（获取新链接），当accept()返回一个连接实体，就fork()出来子进程，只需要专注接收消息。那么连接断了，子进程退出即可，那些残留内容（僵尸进程）去做好垃圾回收。但是进程上下文切换资源开销比较大（为什么大？因为用户空间和内核空间的内存堆栈寄存器啥的都需要切换），所以我们想到可以改成多个线程。</p><p>一个进程中的线程们共享进程的资源，切换的时候只需要改现成的私有数据和寄存器等即可。</p><p>由于创建与销毁线程也需要开销，我们可以提前创建一堆线程。这一坨线程就叫《线程池》（是不是哥嘴里说出来就格外通俗易懂）。</p><p>那么按照我们之前说的，有一个已tcp连接的队列，我们的线程池就可以从队列里取出连接实体进行work了。</p><p>但线程终究也是实体，它是占用空间的一个员工，一次只让他干一个活太浪费了。有没有什么很贱的办法可以压榨员工，让他干更多活呢？接下来我们来说多路复用。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>让一个线程处理多个TCP连接。</p><p>和CPU并发同理，我们可以单个进程轮询多个socket以达到网络层面的并发。有没有注意到，两个形容词都是并发，他们本身就是同一个东西。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="img"></p><p>select&#x2F;poll&#x2F;epoll是三种多路复用模型。</p><p>他们也是内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。</p><h2 id="select-poll"><a href="#select-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h2><p>select简单流程图如下</p><p><img src="/2025/04/03/6/Users\11953\AppData\Roaming\Typora\typora-user-images\image-20250402105007939.png" alt="image-20250402105007939"></p><p>select 使用固定长度的 BitsMap 表示文件描述符集合，而且所支持的文件描述符的个数是有限制的。在Linux 系统中，由内核中的 FD_SETSIZE 限制，默认最大值为 1024，只能监听 0~1023 的文件描述符。</p><p>poll差不多，但用了链表，它的大小就变得动态，稍微好一点点。</p><p>但是二者本质上都是线性遍历，O(n)复杂度，并发数一上来，性能损耗也非常大。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>其实fd再进一步说，在高级语言里，就是类似于一个指针指向一个对象。</p><p>这一次，我们用epoll_create 创建一个 epoll对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll wait 等待数据。</p><p>等待的伪代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> n= epoll_wait(...);</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于一直阻塞然后收到socket就处理。</p><p>epoll在这个领域就是所谓的《经典》。它有两个核心的数据结构</p><p>1.红黑树。对比线性遍历，它的增删改时间复杂度在O(logn)。而且它是长期维护，而不是每次都拷贝整个新的进来。</p><p>2.就绪队列。事件回调机制，复杂度在O(1)，直接添加到就绪链表（双向链表）而不用拷贝和遍历。本质是一个队列，因此先进先出。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll.png" alt="img"></p><p>暂时放一张不是很明确的图，之后再优化一下。</p><p>补充一下，最大连接数就是最大FD数。</p><h3 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h3><p>理解来说，边缘触发就是循环疯狂读写+非阻塞IO（因为只通知一次或者只消费一次，因此要尽力一次操作完），但是《once通知》；而水平触发就是《multi通知》（反复触发直到被取消）</p><p>select&#x2F;poll只支持水平触发，而epoll支持边缘触发和水平触发，水平触发是默认。边缘触发效率更高，因为避免了重复通知，并且只在状态变化时触发，减少了上下文切换。</p><h1 id="2-slice"><a href="#2-slice" class="headerlink" title="2.slice"></a>2.slice</h1><p>slice（切片）。</p><p>之前我们说到数组。但是在go里面统一使用了一个动态扩缩容的数组——slice。接下来研究一下这个。</p><p>关键代码在runtime&#x2F;slice.go。至于为什么在runtime，因为你直接翻译他就是运行时，是语言自带的，而不是语言的包。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice我们注意到他是一个结构体，因此对他的引用就是一个指针指向头，这和C的数组应该是一样的。</p><p>此外，我们的slice包括了len和cap，也就是容量和长度。有人会奇怪这俩不是一样的吗。因为我们slice是动态的，因此我们需要提前去分配内存空间。因此，cap（容量）就是分配的空间，而len是我们数组实际的长度因此一定是有一些位置是空着的。但是为什么空着？因为数组是连续的数据结构，我们需要提前分配连续的空间。如果数组需要加长，而后面的内存有东西，我们则需要再分配一块连续的内存，然后再拷贝过去。这里可以用画图的形式快速展示。</p><p><img src="/2025/04/03/6/Users\11953\AppData\Roaming\Typora\typora-user-images\image-20250403192449144.png" alt="image-20250403192449144"></p><p>可以看到我们len到达6时，原来分配的内存只有5，不够了，因此需要拷贝到新的空间。扩容机制要求cap翻倍。</p><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>看一段代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(data []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">    process(data)</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时输出的data是没有那个append的1的，因为它只传递了值，没有传递地址。完全可以把他看成传进去了一个结构体，而这个结构体是值传递。解决它只需要在前面加上指针：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(data *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *data = <span class="built_in">append</span>(*data, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">    process(&amp;data)</span><br><span class="line">    fmt.Println(data)  <span class="comment">// 输出 [1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>cap&lt;len，则扩容，保持len&lt;&#x3D;cap</p><p>1.len&lt;1024，cap翻倍</p><p>2.len&gt;&#x3D;1024，cap为原来125%</p><p>对于开发者来说容量的作用是什么？就是我们去new它的时候可以提前设置cap大小，来避免反复扩容带来的开销。</p><h3 id="共享内存机制"><a href="#共享内存机制" class="headerlink" title="共享内存机制"></a>共享内存机制</h3><p>切片一个特性是可以截取长度，就像python。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b := a[:<span class="number">2</span>]</span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="number">4</span>)</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></table></figure><p>这一段代码其实a和b操作的都是同一片内存，所以最后输出就是[1,2,4]</p><h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3><p>内存泄漏就是有东西占用内存未被回收，缺不再被管理，显得被管理的内存越来越少，就是内存向外漏了，所以叫内存泄漏。</p><p>1.对于大slice，将不使用部分设置为nil，便于gc回收。</p><p>2.截取切片时，显式拷贝（copy()函数）小slice而不是直接截取。</p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>随便展示一下，具体怎么写需要自己查一下。</p><p>高效拷贝：copy()</p><p>添加内容：append()</p><p>创建：make() </p>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      
      <comments>https://cjliblog.top/2025/04/03/6.%E5%9B%9B%E6%9C%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>5.11月弃文集合</title>
      <link>https://cjliblog.top/2025/03/18/5.11%E6%9C%88%E5%BC%83%E6%96%87%E9%9B%86%E5%90%88/</link>
      <guid>https://cjliblog.top/2025/03/18/5.11%E6%9C%88%E5%BC%83%E6%96%87%E9%9B%86%E5%90%88/</guid>
      <pubDate>Tue, 18 Mar 2025 08:06:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;来自2024年11月一些文集弃文的集合。我改了一下发上来。&lt;/p&gt;
&lt;p&gt;至于为什么变弃文了，是因为居然真的有人看，感觉表现的太中二会让人感</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>来自2024年11月一些文集弃文的集合。我改了一下发上来。</p><p>至于为什么变弃文了，是因为居然真的有人看，感觉表现的太中二会让人感觉当成异类。</p><h2 id="uber阅读"><a href="#uber阅读" class="headerlink" title="uber阅读"></a>uber阅读</h2><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>1.接口类型本身就是指针。如果需要修改其存储的值，需要用指针传递，这样就可以修改原值，否则只能修改拷贝值。进一步说，读可以不用指针，写的话要用指针。</p><p>2.防御性编程。由于go的规则是struct去实现interface的所有func才称作implement，因此存在可能我们漏实现了某个函数却没发现，那么原本构建的逻辑将会被打乱。而添加了一个</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 接口=空结构体</span><br></pre></td></tr></table></figure><p>的判断，如果结构体未implement接口，则编译的时候会报错，因为他们是接不上的。这样就利用人工标注有效地弥补了机制上编译器无法弥补的东西。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span></span> ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.接口被implement的时候，receiver可以是值receiver也可以是pointer receiver。</p><p>4.互斥锁sync.Mutex。由于Mutex的零值是有效地，这代表着var比new声明更好，new浪费内存。因为var是直接在栈上分配变量，而new要在堆上分配对象。如果我们要在结构体里面使用Mutex，建议是建立一个变量。</p><p>如</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后者的Lock()方法，变成了SMap的方法，而前者的Lock方法是SMap.mu的方法。</p><p>5.切片与数组。因为slice和map的底层实现应该是一个指针操作者一篇底层地址。因此，他的本质也是指针。如果我们把它当成值操作容易出问题。如果是复制一个切片，记得重新开辟一片内存。</p><p>6.使用defer：这个设计纯为了防止遗忘。功能强大，不用还容易让代码变复杂。</p><p>7.channel。channel的size应该是1或0，有无缓冲的区别。这样比较干净，而且1经过设计后可以达到和所有非零数字的效果。</p><p>8.iota。Enum中常量自增神器。注意，要从1开始计数。0属于一个默认值，如果是一个正常状态，建议使用0。</p><p>9.error。</p><ul><li>最好用static定义，这样我们可以case讨论，同时省略一些同质化的内存。</li><li>error返回动态值，我们用fmt的sprintf。</li><li>报错保持上下文简介，避免“failed to “这种语义冗余。</li><li>把Err作为前缀，可以用于区分这个err是否导出。如果上一行log了就不要再return err。</li></ul><p>10.panic。不要滥用恐慌，因为不容易排查错误。</p><p>1.书接上回，别用panic。程序内部烂了才会用，因为这样的报错一坨，太难查了。</p><p>2.原子操作使用<a href="https://pkg.go.dev/go.uber.org/atomic">go.uber.org&#x2F;atomic</a>（内置广告hh），比原生包用着舒服。</p><p>3.一些不好改变的东西，不要直接引用，要用结构体去new。</p><p>4.公共结构体别嵌入类型，如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ConcreteList is a list of entities.</span><br><span class="line">type ConcreteList struct &#123;</span><br><span class="line">  *AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.避免init，因为init容易在代码发生变动的时候发生顺序错乱，调整比较麻烦。另外，实在要用的话，init要避免全局操作或者io操作。协程别出现。</p><p>6.strconv比sprintf更快</p><p><img src="https://raw.githubusercontent.com/yuuki798/pic-list/main/blog/image-20241111193433855.png" alt="image-20241111193433855"></p><p>7.多去声明而不是缩成一坨，往往能性能更棒。</p><p><img src="https://raw.githubusercontent.com/yuuki798/pic-list/main/blog/image-20241111193605513.png" alt="image-20241111193605513"></p><p>8.切片指定容量来提高性能</p><p>9.代码一行不超过99字符（不要太长即可）。一个项目风格要保持一致。</p><p>10.减少嵌套，如果if里面套if，不如直接拿出来两个if。</p><p>11.原始字符串可以避免转义</p><p><img src="https://raw.githubusercontent.com/yuuki798/pic-list/main/blog/image-20241111195104563.png" alt="image-20241111195104563"></p><p>12.别new。一次性声明完。</p><p><img src="https://raw.githubusercontent.com/yuuki798/pic-list/main/blog/image-20241111195256356.png" alt="image-20241111195256356"></p><p>到此就over了。原来其实大名鼎鼎的uber规范也就是一些细节上的统一罢了，我已经将小部分有启发的搬上了第零周和第二周学习笔记，希望对自己和大家都有所帮助。</p><h2 id="k3s的pod调度"><a href="#k3s的pod调度" class="headerlink" title="k3s的pod调度"></a>k3s的pod调度</h2><p>主要是利用tag。先给某个机子打上tag，然后让其他set去绑定就可以。</p><h2 id="产品阅读"><a href="#产品阅读" class="headerlink" title="产品阅读"></a>产品阅读</h2><h3 id="引导式设计——用户第一关"><a href="#引导式设计——用户第一关" class="headerlink" title="引导式设计——用户第一关"></a>引导式设计——用户第一关</h3><p>对于产品的引导式设计。我们知道很多互联网产品，都会有开局《新手教程》类似的东西，但是这种很烦，其实用户不喜欢一些乱七八糟的指导一下子涌上来，而是喜欢自己探索。apple公司喜欢采用非引导式的隐藏设计，比如左滑右滑。这会让用户在不知不觉学会这汇总用法，或者通过人与人的沟通习得一个《小妙招》。这简洁而精妙。</p><p>然后可以看到最近hz的奖学金系统。给大家做了一堆培训，却老是出现制度方面有钻漏洞行为的事情，被各种举报。首先这个是技术人员没有考虑到产品的易上手性，这也是产品设计环节没考虑清楚用户-系统之间交互而诞生的问题。辅导员不一定都是计算机毕业的，所以可能有的人压根没有那么调理清晰的工程思维来处理一些树；就算有这样的思维他也需要花很多成本去学习期中的规则，那有时候甚至不如人力excel表。这样用户会感到操作复杂，学习或使用投入成本大，不乐意花时间，把权力交给学生，所以强制使用就会出现非常多的问题。甚至差点被叫停。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>作为一个对奖项最忌恨的人，居然在搬上先进班集体荧幕的时候变成了只靠奖项出彩的人。回去读了之前写的《黑神话》一文，深有感慨。一是感慨就过了一个月居然都忘了之前写了什么，感觉读了新文章的感觉，震撼我居然能写出这样的句子；二是感慨我狂喷奖项，疯狂做自己热爱的事，如今已经初步完成了当初的执念，然而却在荧幕上成为了我很抵制的人。也可能有些名誉是随热爱而来的吧。进一步诠释热爱的强势。</p>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/2025%E6%98%A5/">2025春</category>
      
      
      
      <comments>https://cjliblog.top/2025/03/18/5.11%E6%9C%88%E5%BC%83%E6%96%87%E9%9B%86%E5%90%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>新建 Markdown file</title>
      <link>https://cjliblog.top/2025/03/18/%E6%96%B0%E5%BB%BA%20Markdown%20file/</link>
      <guid>https://cjliblog.top/2025/03/18/%E6%96%B0%E5%BB%BA%20Markdown%20file/</guid>
      <pubDate>Tue, 18 Mar 2025 07:34:08 GMT</pubDate>
      
        
        
      <description>&lt;hr&gt;
&lt;h2 id=&quot;title-新建-Markdown-filedate-2025-03-18-15-33-47top-categories-a&quot;&gt;&lt;a href=&quot;#title-新建-Markdown-filedate-2025-03-18-15-33-47top-cat</description>
        
      
      
      
      <content:encoded><![CDATA[<hr><h2 id="title-新建-Markdown-filedate-2025-03-18-15-33-47top-categories-a"><a href="#title-新建-Markdown-filedate-2025-03-18-15-33-47top-categories-a" class="headerlink" title="title: 新建 Markdown filedate: 2025-03-18 15:33:47top:categories: a"></a>title: 新建 Markdown file<br>date: 2025-03-18 15:33:47<br>top:<br>categories: a</h2><hr><h2 id="title-新建-Markdown-filedate-2025-03-18-15-32-23top-categories-a"><a href="#title-新建-Markdown-filedate-2025-03-18-15-32-23top-categories-a" class="headerlink" title="title: 新建 Markdown filedate: 2025-03-18 15:32:23top:categories: a"></a>title: 新建 Markdown file<br>date: 2025-03-18 15:32:23<br>top:<br>categories: a</h2><hr><h2 id="title-新建-Markdown-filedate-2025-03-18-15-32-11top-categories-a"><a href="#title-新建-Markdown-filedate-2025-03-18-15-32-11top-categories-a" class="headerlink" title="title: 新建 Markdown filedate: 2025-03-18 15:32:11top:categories: a"></a>title: 新建 Markdown file<br>date: 2025-03-18 15:32:11<br>top:<br>categories: a</h2><hr><h2 id="title-新建-Markdown-filedate-2025-03-18-15-13-43top-categories-test"><a href="#title-新建-Markdown-filedate-2025-03-18-15-13-43top-categories-test" class="headerlink" title="title: 新建 Markdown filedate: 2025-03-18 15:13:43top:categories: test"></a>title: 新建 Markdown file<br>date: 2025-03-18 15:13:43<br>top:<br>categories: test</h2><hr><h2 id="title-新建-Markdown-filedate-2025-03-18-15-10-08top-categories-test"><a href="#title-新建-Markdown-filedate-2025-03-18-15-10-08top-categories-test" class="headerlink" title="title: 新建 Markdown filedate: 2025-03-18 15:10:08top:categories: test"></a>title: 新建 Markdown file<br>date: 2025-03-18 15:10:08<br>top:<br>categories: test</h2><hr><h2 id="title-新建-Markdown-filedate-2025-03-18-15-07-12top-categories-test"><a href="#title-新建-Markdown-filedate-2025-03-18-15-07-12top-categories-test" class="headerlink" title="title: 新建 Markdown filedate: 2025-03-18 15:07:12top:categories: test"></a>title: 新建 Markdown file<br>date: 2025-03-18 15:07:12<br>top:<br>categories: test</h2><p>test</p>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/a/">a</category>
      
      
      
      <comments>https://cjliblog.top/2025/03/18/%E6%96%B0%E5%BB%BA%20Markdown%20file/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>踩坑记录Windows 删除文件/文件夹提示“找不到该项目</title>
      <link>https://cjliblog.top/2024/10/22/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95Windows%20%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8F%90%E7%A4%BA%E2%80%9C%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE/</link>
      <guid>https://cjliblog.top/2024/10/22/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95Windows%20%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8F%90%E7%A4%BA%E2%80%9C%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE/</guid>
      <pubDate>Mon, 21 Oct 2024 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;删除文件夹时，发现其中存在一个顽固文件，不管怎么删除都会提示”&lt;strong&gt;找不到该项目&lt;/strong&gt;“，无法删除。&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>删除文件夹时，发现其中存在一个顽固文件，不管怎么删除都会提示”<strong>找不到该项目</strong>“，无法删除。</p><p>根据网络所见，貌似文件夹也存在这种情况。</p><h2 id="问题猜想"><a href="#问题猜想" class="headerlink" title="问题猜想"></a>问题猜想</h2><p>我这里存在的问题推测是因为文件名末尾多带了一个 <code>.</code>，即类似于 <code>example.file.txt.</code>，正常操作是无法创建这样的文件的，貌似我这里是由于旧版本 adb 的 bug 所产生。</p><p>该文件并非无拓展名，具体肯定是属于异常情况，但这里不深究。</p><p>据说文件夹也存在这样的异常。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>这里提供我试验过后的成功方法。</p><p>创建一个 <code>del.bat</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del /f /a /q \\?\%1</span><br><span class="line">rd /s /q \\?\%1</span><br></pre></td></tr></table></figure><p>然后<strong>将要删除的东西拖到这个批处理文件</strong>上即可。</p><p>我这里直接拖入顽固文件不起作用，但是<strong>将顽固文件所在的文件夹直接拖入</strong>就删除成功了。</p><p>如果连正常文件都无法起作用，重新创建批处理文件并将编码修改为 ANSI。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>右键，选择 Winrar 的添加到压缩文件，并勾选删除源文件（或者叫”压缩后删除原来的文件“）。</p><p>我这里直接对顽固文件进行操作未能成功，没有对所在文件夹尝试过，一些网友说有用，故也记录下来。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://blog.csdn.net/qq_41042595/article/details/112576438">Windows桌面文件夹删除被提示“找不到该项目”——顽固目录、文件的删除_电脑桌面文件夹删除提示找不到该项目-CSDN博客</a></li></ol><h3 id="版权信息"><a href="#版权信息" class="headerlink" title="版权信息"></a>版权信息</h3><p>本文原载于 <a href="https://blog.reincarnatey.net/">reincarnatey.net</a>，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。</p>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/%E8%BD%AC%E8%BD%BD/">转载</category>
      
      
      
      <comments>https://cjliblog.top/2024/10/22/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95Windows%20%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8F%90%E7%A4%BA%E2%80%9C%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>爬虫笔记</title>
      <link>https://cjliblog.top/2024/08/31/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</link>
      <guid>https://cjliblog.top/2024/08/31/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Fri, 30 Aug 2024 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;昨日爬虫学习与改造记录&quot;&gt;&lt;a href=&quot;#昨日爬虫学习与改造记录&quot; class=&quot;headerlink&quot; title=&quot;昨日爬虫学习与改造记录&quot;&gt;&lt;/a&gt;昨日爬虫学习与改造记录&lt;/h3&gt;&lt;p&gt;在今天的学习与实践中，我对一个使用 Selenium 进行招聘信息抓</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="昨日爬虫学习与改造记录"><a href="#昨日爬虫学习与改造记录" class="headerlink" title="昨日爬虫学习与改造记录"></a>昨日爬虫学习与改造记录</h3><p>在今天的学习与实践中，我对一个使用 Selenium 进行招聘信息抓取的爬虫脚本进行了深入改造。通过代码优化与问题解决，我对如何设计、优化和调试爬虫有了更深入的理解。本文将详细记录今天的学习过程、遇到的问题以及改进后的代码。</p><h4 id="1-初步爬虫脚本构建"><a href="#1-初步爬虫脚本构建" class="headerlink" title="1. 初步爬虫脚本构建"></a>1. 初步爬虫脚本构建</h4><p>最初的爬虫脚本结构相对简单，主要实现了以下功能：</p><ul><li><strong>页面加载与点击</strong>：通过 Selenium 模拟浏览器操作，访问目标招聘网站并点击分类页面。</li><li><strong>数据提取</strong>：逐一遍历分类页面，提取每个职位的详细信息，包括职位名称、公司、地点、薪资等，并保存到数据库。</li><li><strong>数据库操作</strong>：每获取到一个职位信息，都会连接数据库并插入数据。</li></ul><h4 id="初始代码（部分摘录）"><a href="#初始代码（部分摘录）" class="headerlink" title="初始代码（部分摘录）"></a>初始代码（部分摘录）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser = webdriver.Edge()</span><br><span class="line">index_url = <span class="string">&#x27;https://www.zhipin.com/?city=100010000&amp;ka=city-sites-100010000&#x27;</span></span><br><span class="line">browser.get(index_url)</span><br><span class="line"></span><br><span class="line">show_ele = browser.find_element(by=By.XPATH, value=<span class="string">&#x27;//*[@id=&quot;main&quot;]/div/div[1]/div/div[1]/dl[1]/dd/b&#x27;</span>)</span><br><span class="line">show_ele.click()</span><br><span class="line"></span><br><span class="line">today = datetime.date.today().strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">85</span>):</span><br><span class="line">    current_a = browser.find_elements(by=By.XPATH, value=<span class="string">&#x27;//*[@id=&quot;main&quot;]/div/div[1]/div/div[1]/dl[1]/div/ul/li/div/a&#x27;</span>)[i]</span><br><span class="line">    current_category = current_a.find_element(by=By.XPATH, value=<span class="string">&#x27;../../h4&#x27;</span>).text</span><br><span class="line">    sub_category = current_a.text</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;正在抓取&#123;&#125;--&#123;&#125;&quot;</span>.<span class="built_in">format</span>(today, current_category, sub_category))</span><br><span class="line">    current_a.click()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    browser.execute_script(<span class="string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    browser.execute_script(<span class="string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)</span><br><span class="line">    <span class="comment"># 提取并保存职位数据...</span></span><br></pre></td></tr></table></figure><p>这个代码的问题在于：</p><ol><li><strong>页面元素加载问题</strong>：在页面元素尚未完全加载时，Selenium 可能无法找到目标元素，从而导致失败。</li><li><strong>StaleElementReferenceException</strong>：当页面刷新或 DOM 结构发生变化时，Selenium 引用的元素会失效，导致操作失败。</li><li><strong>频繁的数据库连接</strong>：每获取一个职位信息都会新建一次数据库连接，导致效率低下。</li><li><strong>手动处理验证码</strong>：当网站检测到异常行为时，可能会触发验证码验证，这会中断爬虫运行。</li></ol><h4 id="2-改进与优化"><a href="#2-改进与优化" class="headerlink" title="2. 改进与优化"></a>2. 改进与优化</h4><p>针对上述问题，我进行了多方面的改进，以下是主要的优化措施和相应的代码改变。</p><h5 id="2-1-引入重试机制"><a href="#2-1-引入重试机制" class="headerlink" title="2.1 引入重试机制"></a>2.1 引入重试机制</h5><p>为了应对页面元素加载失败或 DOM 变化带来的问题，我增加了一个 <code>retry_on_failure</code> 函数。该函数允许在遇到 <code>StaleElementReferenceException</code> 或 <code>TimeoutException</code> 时，自动重试指定次数，提高脚本的稳定性。</p><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> StaleElementReferenceException, TimeoutException</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retry_on_failure</span>(<span class="params">max_retries, function, *args, **kwargs</span>):</span><br><span class="line">    retries = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> retries &lt; max_retries:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> function(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> (StaleElementReferenceException, TimeoutException) <span class="keyword">as</span> e:</span><br><span class="line">            retries += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>. Retrying <span class="subst">&#123;retries&#125;</span>/<span class="subst">&#123;max_retries&#125;</span>...&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">f&quot;Failed after <span class="subst">&#123;max_retries&#125;</span> retries&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">current_a = retry_on_failure(<span class="number">3</span>, browser.find_elements, By.XPATH, <span class="string">&#x27;//*[@id=&quot;main&quot;]/div/div[1]/div/div[1]/dl[1]/div/ul/li/div/a&#x27;</span>)[i]</span><br></pre></td></tr></table></figure><h5 id="2-2-优化页面跳转与元素定位"><a href="#2-2-优化页面跳转与元素定位" class="headerlink" title="2.2 优化页面跳转与元素定位"></a>2.2 优化页面跳转与元素定位</h5><p>为了减少页面跳转带来的定位失效问题，我在点击元素前引入了显式等待，并结合了动作链（ActionChains）来确保元素能够正确点击。这有效减少了 <code>StaleElementReferenceException</code> 发生的概率。</p><p>同时，为了避免在复杂的页面场景中可能出现的点击失效问题，我将一些关键点击操作改为使用 JavaScript 强制执行。这种方式在某些情况下比 Selenium 的普通点击操作更为可靠。</p><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">show_ele = WebDriverWait(browser, <span class="number">10</span>).until(</span><br><span class="line">    EC.element_to_be_clickable((By.XPATH, <span class="string">&#x27;//*[@id=&quot;main&quot;]/div/div[1]/div/div[1]/dl[1]/dd/b&#x27;</span>))</span><br><span class="line">)</span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.move_to_element(show_ele).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 JavaScript 强制执行点击</span></span><br><span class="line">browser.execute_script(<span class="string">&quot;arguments[0].click();&quot;</span>, current_a)</span><br></pre></td></tr></table></figure><h5 id="2-3-增加-sleep-等待"><a href="#2-3-增加-sleep-等待" class="headerlink" title="2.3 增加 sleep 等待"></a>2.3 增加 <code>sleep</code> 等待</h5><p>为了确保页面元素完全加载，我在一些关键步骤前增加了 <code>sleep</code> 等待。这种方式虽然简单，但在处理需要等待页面完全渲染的场景时非常有效。</p><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 等待页面加载</span></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 滚动页面以加载更多内容</span></span><br><span class="line">browser.execute_script(<span class="string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">browser.execute_script(<span class="string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="2-4-优化数据库连接"><a href="#2-4-优化数据库连接" class="headerlink" title="2.4 优化数据库连接"></a>2.4 优化数据库连接</h5><p>为了提高数据库操作的效率，我在程序启动时建立了一次数据库连接，并在整个脚本运行过程中复用该连接。这样做不仅减少了每次操作时的连接开销，还提升了程序的整体性能。</p><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动时建立数据库连接</span></span><br><span class="line">db = DBUtils(<span class="string">&#x27;数据库地址&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>, <span class="string">&#x27;数据库名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在后续操作中复用该连接，而不是每次都新建连接</span></span><br><span class="line">db.insert_data(</span><br><span class="line">    <span class="string">&quot;insert into job_info(category, sub_category, job_title, province, job_location, job_company, job_industry, job_finance, job_scale, job_welfare, job_salary_range, job_experience, job_education, job_skills, create_time) values(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)&quot;</span>,</span><br><span class="line">    args=(current_category, sub_category, job_title, province, job_location, job_company, job_industry, job_finance, job_scale, job_welfare, job_salary_range, job_experience, job_education, job_skills, today)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="2-5-处理验证码与异常页面"><a href="#2-5-处理验证码与异常页面" class="headerlink" title="2.5 处理验证码与异常页面"></a>2.5 处理验证码与异常页面</h5><p>在爬虫运行过程中，有时会遇到页面弹出验证码的情况。为了确保爬虫的持续运行，我增加了一个等待用户手动操作的功能，使得用户可以在需要时手动完成验证，然后继续自动化抓取。</p><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wait_for_user</span>():</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;请手动完成操作后在控制台输入 &#x27;ok&#x27; 继续: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在需要时调用</span></span><br><span class="line">wait_for_user()</span><br></pre></td></tr></table></figure><h5 id="2-6-日志记录与进度反馈"><a href="#2-6-日志记录与进度反馈" class="headerlink" title="2.6 日志记录与进度反馈"></a>2.6 日志记录与进度反馈</h5><p>为了更好地监控爬虫的运行状态，我在脚本中增加了详细的日志输出，每个关键步骤都会记录日志，以便在发生问题时能够快速定位。此外，还增加了进度反馈，使得用户可以清楚地了解脚本的处理进度。</p><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在处理第 <span class="subst">&#123;i&#125;</span> 个分类（咱程序员喜欢从0开始数你懂得...）&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;today&#125;</span> 正在抓取 <span class="subst">&#123;current_category&#125;</span> -- <span class="subst">&#123;sub_category&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="3-改造后的爬虫运行效果"><a href="#3-改造后的爬虫运行效果" class="headerlink" title="3. 改造后的爬虫运行效果"></a>3. 改造后的爬虫运行效果</h4><p>经过优化后的爬虫，运行更加稳定高效，处理数据的速度有了明显提升，并且在应对复杂页面场景时表现更佳。以下是改造后脚本的一些显著优点：</p><ul><li><strong>稳定性提升</strong>：通过重试机制和显式等待，有效减少了因元素定位失败导致的脚本中断。</li><li><strong>效率提升</strong>：通过优化数据库连接和减少页面跳转次数，大幅提高了数据抓取的效率。</li><li><strong>更好的用户交互</strong>：增加的日志输出和手动操作提示，使得脚本在自动化与人工干预之间达到了更好的平衡。</li></ul>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      
      <category domain="https://cjliblog.top/tags/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      
      <comments>https://cjliblog.top/2024/08/31/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>黑神话悟空日与我无关但是我没睡着天就亮了</title>
      <link>https://cjliblog.top/2024/08/20/%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E6%97%A5%E4%B8%8E%E6%88%91%E6%97%A0%E5%85%B3%E4%BD%86%E6%98%AF%E6%88%91%E6%B2%A1%E7%9D%A1%E7%9D%80%E5%A4%A9%E5%B0%B1%E4%BA%AE%E4%BA%86/</link>
      <guid>https://cjliblog.top/2024/08/20/%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E6%97%A5%E4%B8%8E%E6%88%91%E6%97%A0%E5%85%B3%E4%BD%86%E6%98%AF%E6%88%91%E6%B2%A1%E7%9D%A1%E7%9D%80%E5%A4%A9%E5%B0%B1%E4%BA%AE%E4%BA%86/</guid>
      <pubDate>Mon, 19 Aug 2024 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h4&gt;&lt;p&gt;有时候感觉时间就挺多的，如果不睡觉的话，还有心情写点儿日记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;白天就感觉时间挺少的，如果睡到十点左右，起来刷一会儿手机</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>有时候感觉时间就挺多的，如果不睡觉的话，还有心情写点儿日记。</p><p><strong>白天就感觉时间挺少的，如果睡到十点左右，起来刷一会儿手机就中午了。</strong>中午边娱乐边吃饭，下午又睡满了。晚上在电脑前做些杂七杂八的动作，好像是在水群其实，断断续续看点教学视频，感觉生活好像要有点起色了，但一会儿就九点了，然后就醒悟过来，视频时长合起来可能就只有半个小时，倒是娱乐视频看了超过一个小时。</p><p>半夜玩起小游戏，前端又来和我对接口了，但是我啥都没动，准备装睡。</p><p>躺了好久，在幻想自己的一场华丽的演讲和讲得头头是道的无数的人生哲理，仿佛自己就是赢家。哎，都没做梦，只是夜晚做了个白日梦。哪怕是在完美的幻想里，满嘴说着“他妈的”也让自己的形象显得非常的帅。</p><h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>还有一副横幅，气势磅礴，and座无虚席——“千里逢迎，高朋满座”。</p><p>一种江湖的气派。我要告诉世人，从古至今，真正的技艺都是传承，拜师求学，用心传授，才是学习本来的样子。这种每个学生被迫分配一个老师，一个老师被迫分配一堆学生，没有产生吸引和匹配，就是一堆工具的相互利用，像是社会机器的运转。</p><p><strong>人好为人师，可以美其名费曼学习法。</strong>说先天的，就是装逼。说没有的，就是吹逼。而说自己最近学到的、想到的，还真可以叫费曼学习法。逻辑自洽，也不无赖。</p><p>思维的“滞后”，其实就是脱节嘛。那就在于身边的人并不“先进”嘛。那又凭什么说“牛逼的人到哪都牛逼”？那是因为他先前就已经有了丰厚的见识和资源，或者有某股力量在暗中助力，别人不知道。</p><p>“中学生思维“就三种：”绩优主义务虚主义天天奋斗爱当奴隶逆来顺受型“、”我很牛逼但是人生不得志可是看到大佬我又疯狂跪舔型“、”智商决定一切我就是不行上天不公平叫苦连篇型“。三种不沾一种，恭喜你，你成熟了，但只是相对成熟，进入了”大学生思维“。对于社会人士，你还是太年轻。</p><h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><p>年轻的梦想其实都可以实现，没有什么时间不够，时间都是被自己夺走了。</p><p>少参加点比赛，少看点没营养的网络内容，少在社交平台当显眼包，不就好了。甚至还可以剥夺睡眠。</p><p>二十四小时的一天，让人感到自在，仿佛我每天也可以抽点时间出来练习文笔和思想，当个文艺青年。</p><p>甚至感觉写了大半天，噢哟喝，才过了三十来分钟呢，才五点多，也太早了吧，放在高中室友也都还没起床呢。</p><p>一些心理作用是在无形压垮一些傻逼的。整天胡乱参加比赛，胡乱参加活动，任何的作业也要做的天衣无缝，所有的比赛、活动、作业、科研都要把自己的面子工程做到极致，整天想当励志逆袭的典范，整天把绩点之类的形式上的评价奉为圭臬，整天想当人上人，整天以为自己写论文做科研就是大神，整天以为自己学一点别人不知道的技术就是帅，整天把自己偷偷卷一些事情当成嘲笑他人的了不起的资本，整天胡乱接收一些是非信息然后开始评价别人评价世界，整天因为情绪不稳定和别人逼逼赖赖或者心里把自己想成一个悲情主角。。。这不是某个人，这是好几类人的画像。“太忙”好像变成了一个装逼词汇，但是没有人真正思考过这有没有可能是一个贬义词，是不懂得自己应该如何为自己争取时间价值的代名词，随着自己的事情被“B事”填满而变得麻木又自豪，一边嘴上骂着事情多，一边享受这种忙碌给自己带来的莫名自信的荣誉感，在绩优主义的评价体系下，“呵呵又努力了一天”的阿Q精神。</p><p>哎，消愁的小丑。</p><p><strong>而当凌晨清脆鸟声伴随着的青涩阳光和稀薄的空气弥漫过房间，一切的思绪都是如纸张那般不可掂量的轻。</strong></p><p><img src="https://ice.frostsky.com/2024/08/20/8756ece81515642011d8dfb1c222db82.png" alt="而当凌晨清脆鸟声伴随着的青涩阳光和稀薄的空气弥漫过房间，一切的思绪都是如纸张那般不可掂量的轻。"></p><p><strong>有个即兴的词组叫胜利的曙光。</strong></p><h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4><p>就是啊，谁不曾有个自己曾经期望的自己呢，凭什么给外界的传统评价体系定义了自己。</p><p>外界也可以创造出多元的评价。艺术再小，总有受众。哲学再冷，也成门派。一切皆有可能。</p><p>不必把自己做成一台机器，或者一部工具，像火车空笼闶阆运转个不停，一班接着一班。</p><p><strong>再享受一下宁静，再感受一下生命存在的意义。</strong>再走进人群，也许此刻又会有不一样的决定，还有仍然被称作年少的这个时刻的一个少年的梦。</p><p><img src="https://ice.frostsky.com/2024/08/20/bf7ed7aa2d636048c8cfb63daa30f2ac.png" alt="再享受一下宁静，再感受一下生命存在的意义。"></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">morningSunrise</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The morning sunrise... A new beginning.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/%E6%95%A3%E6%96%87/">散文</category>
      
      
      <category domain="https://cjliblog.top/tags/%E6%95%A3%E6%96%87/">散文</category>
      
      
      <comments>https://cjliblog.top/2024/08/20/%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E6%97%A5%E4%B8%8E%E6%88%91%E6%97%A0%E5%85%B3%E4%BD%86%E6%98%AF%E6%88%91%E6%B2%A1%E7%9D%A1%E7%9D%80%E5%A4%A9%E5%B0%B1%E4%BA%AE%E4%BA%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>国内镜像</title>
      <link>https://cjliblog.top/2024/08/16/docker%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%9C%80%E6%96%B0%E2%80%94%E2%80%94%E5%A4%87%E4%BB%BD/</link>
      <guid>https://cjliblog.top/2024/08/16/docker%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%9C%80%E6%96%B0%E2%80%94%E2%80%94%E5%A4%87%E4%BB%BD/</guid>
      <pubDate>Thu, 15 Aug 2024 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;DockerHub国内镜像源列表&quot;&gt;&lt;a href=&quot;#DockerHub国内镜像源列表&quot; class=&quot;headerlink&quot; title=&quot;DockerHub国内镜像源列表&quot;&gt;&lt;/a&gt;DockerHub国内镜像源列表&lt;/h2&gt;&lt;p&gt;此列表只收录无需限定条件的D</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="DockerHub国内镜像源列表"><a href="#DockerHub国内镜像源列表" class="headerlink" title="DockerHub国内镜像源列表"></a>DockerHub国内镜像源列表</h2><p>此列表只收录无需限定条件的DockerHub镜像源，感谢这些公益服务者。</p><p><strong>2024年6月18日 亲测可用</strong></p><table><thead><tr><th align="left">DockerHub镜像仓库</th><th align="left">镜像加速器地址</th></tr></thead><tbody><tr><td align="left"><a href="https://hub.uuuadc.top/">Docker镜像加速站 722</a></td><td align="left"><code>https://hub.uuuadc.top/</code></td></tr><tr><td align="left"></td><td align="left"><code>docker.1panel.live</code></td></tr><tr><td align="left"></td><td align="left"><code>hub.rat.dev</code></td></tr><tr><td align="left"><a href="https://docker.anyhub.us.kg/">DockerHub 镜像加速代理 316</a></td><td align="left"><code>https://docker.anyhub.us.kg</code></td></tr><tr><td align="left"></td><td align="left"><code>https://docker.chenby.cn</code></td></tr><tr><td align="left"></td><td align="left"><code>https://dockerhub.jobcher.com/</code></td></tr><tr><td align="left"><a href="https://dockerhub.icu/">镜像使用说明 289</a></td><td align="left"><code>https://dockerhub.icu</code></td></tr><tr><td align="left"><a href="https://docker.ckyl.me/">Docker镜像加速站 108</a></td><td align="left"><code>https://docker.ckyl.me</code></td></tr><tr><td align="left"><a href="https://docker.awsl9527.cn/">镜像使用说明 114</a></td><td align="left"><code>https://docker.awsl9527.cn</code></td></tr><tr><td align="left"><a href="https://docker.hpcloud.cloud/">镜像使用说明 90</a></td><td align="left"><code>https://docker.hpcloud.cloud</code></td></tr><tr><td align="left"><a href="https://atomhub.openatom.cn/">AtomHub 可信镜像仓库平台 112</a>（只包含基础镜像，共336个）</td><td align="left"><code>https://atomhub.openatom.cn</code></td></tr><tr><td align="left"><a href="https://github.com/DaoCloud/public-image-mirror">DaoCloud 镜像站 223</a></td><td align="left"><code>https://docker.m.daocloud.io</code></td></tr></tbody></table><h3 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h3><ol><li>为了加速镜像拉取，使用以下命令设置<strong>registry mirror</strong></li></ol><blockquote><p>支持系统：Ubuntu 16.04+、Debian 8+、CentOS 7+</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">        &quot;https://hub.uuuadc.top&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://docker.anyhub.us.kg&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://dockerhub.jobcher.com&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://dockerhub.icu&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://docker.ckyl.me&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://docker.awsl9527.cn&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ol><li>使用DockerHub Proxy，以下以 <code>hub.uuuadc.top</code> 为例：可以根据列表自行替换</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull hub.uuuadc.top/library/mysql:5.7</span><br></pre></td></tr></table></figure><p>说明：library是一个特殊的命名空间，它代表的是官方镜像。如果是某个用户的镜像就把library替换为镜像的用户名</p><p>原文链接：<br><a href="https://www.wangdu.site/course/2109.html">https://www.wangdu.site/course/2109.html</a></p><h2 id="npm镜像"><a href="#npm镜像" class="headerlink" title="npm镜像"></a>npm镜像</h2><p><a href="https://cloud.tencent.com/developer/article/1372949">https://cloud.tencent.com/developer/article/1372949</a></p><p>使用自己的服务器作为上网代理来更换 IP 访问网站，可以通过设置一个代理服务器来实现。以下是使用 SSH 隧道和 Squid 代理两种常见的实现方法：</p><h2 id="更换IP方法"><a href="#更换IP方法" class="headerlink" title="更换IP方法"></a>更换IP方法</h2><h3 id="方法一：使用-SSH-隧道"><a href="#方法一：使用-SSH-隧道" class="headerlink" title="方法一：使用 SSH 隧道"></a>方法一：使用 SSH 隧道</h3><p>这种方法适合临时更换 IP。</p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li><p><strong>拥有一台远程服务器</strong>：确保你有一台可以通过 SSH 访问的远程服务器，该服务器的 IP 地址将成为你访问网站时显示的 IP 地址。</p></li><li><p><strong>使用 SSH 隧道</strong>：</p><ul><li><p>在本地计算机上打开终端（或使用 PuTTY 等 SSH 客户端）。</p></li><li><p>使用以下命令创建一个 SSH 隧道：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -D 1080 -q -C -N username@your_server_ip</span><br></pre></td></tr></table></figure></li><li><p>解释：</p><ul><li><code>-D 1080</code>：在本地创建一个动态端口转发（SOCKS 代理）在端口 1080。</li><li><code>-q</code>：安静模式，减少输出。</li><li><code>-C</code>：压缩数据。</li><li><code>-N</code>：不执行远程命令，仅转发端口。</li><li><code>username@your_server_ip</code>：你的服务器用户名和 IP 地址。</li></ul></li></ul></li><li><p><strong>配置浏览器</strong>：</p><ul><li>在浏览器中设置代理，使用 SOCKS5 代理，地址为 <code>127.0.0.1</code>，端口为 <code>1080</code>。</li><li>这样，你的浏览器访问网络时就会通过你的服务器，显示服务器的 IP 地址。</li></ul></li></ol><h3 id="方法二：使用-Squid-代理"><a href="#方法二：使用-Squid-代理" class="headerlink" title="方法二：使用 Squid 代理"></a>方法二：使用 Squid 代理</h3><p>适合长期使用或多设备共享。</p><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol><li><p><strong>安装 Squid</strong>：</p><ul><li><p>登录到你的服务器，安装 Squid 代理服务器：</p><p><strong>Debian&#x2F;Ubuntu</strong>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install squid</span><br></pre></td></tr></table></figure><p><strong>CentOS&#x2F;RHEL</strong>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install squid</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>配置 Squid</strong>：</p><ul><li><p>编辑 Squid 的配置文件（通常位于 <code>/etc/squid/squid.conf</code>）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/squid/squid.conf</span><br></pre></td></tr></table></figure></li><li><p>查找并修改以下配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_access allow all</span><br></pre></td></tr></table></figure></li><li><p>设置 Squid 监听的端口（通常是 3128）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_port 3128</span><br></pre></td></tr></table></figure></li><li><p>保存并退出配置文件。</p></li></ul></li><li><p><strong>启动 Squid</strong>：</p><ul><li><p>启动 Squid 服务并设置为开机自启：</p><p><strong>Debian&#x2F;Ubuntu</strong>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start squid</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> squid</span><br></pre></td></tr></table></figure><p><strong>CentOS&#x2F;RHEL</strong>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start squid</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> squid</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>配置防火墙</strong>（如果适用）：</p><ul><li>确保服务器上的防火墙允许 Squid 的端口（如 3128）的入站连接。</li></ul></li><li><p><strong>配置客户端浏览器</strong>：</p><ul><li>在浏览器或操作系统的网络设置中，将代理服务器设置为你服务器的 IP 地址，端口为 Squid 代理的端口（通常是 3128）。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>SSH 隧道</strong>：适合临时个人使用，配置简单，但需要在每次使用时手动建立连接。</li><li><strong>Squid 代理</strong>：适合多用户和长期使用，配置稍复杂，但更加灵活和强大。</li></ul><p>无论使用哪种方法，你的 IP 地址都会显示为服务器的 IP，便于更换访问某些网站时的地理位置或绕过某些限制。</p>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <category domain="https://cjliblog.top/tags/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <comments>https://cjliblog.top/2024/08/16/docker%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%9C%80%E6%96%B0%E2%80%94%E2%80%94%E5%A4%87%E4%BB%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>24-7-6</title>
      <link>https://cjliblog.top/2024/07/06/24-7-6/</link>
      <guid>https://cjliblog.top/2024/07/06/24-7-6/</guid>
      <pubDate>Fri, 05 Jul 2024 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1-引子&quot;&gt;&lt;a href=&quot;#1-引子&quot; class=&quot;headerlink&quot; title=&quot;1 引子&quot;&gt;&lt;/a&gt;1 引子&lt;/h2&gt;&lt;p&gt;今天开始写一点有质量的博客，比如攒几天发一篇。&lt;/p&gt;
&lt;p&gt;最近最大的事迹就是期末考结束和推掉所有科研和竞赛。&lt;/p&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1 引子"></a>1 引子</h2><p>今天开始写一点有质量的博客，比如攒几天发一篇。</p><p>最近最大的事迹就是期末考结束和推掉所有科研和竞赛。</p><p>抱着过了就好的心态，整个期末过程其实可以说是没什么压力的，虽然挂了一科。但是也导致一个经常恶意熬夜、爱打游戏、过度恶意水作业和过度恶意旷课的坏毛病。</p><p>不得不说，single的日子过的非常舒坦，得益于情绪起伏低，步步为营有更多的思考时间和空间，然后可以按照自己的节奏随意阅读、自研、娱乐、运动等。不过也有必要思考为什么处在人际关系情形下，人容易失去理智。</p><p>其他的事情，阅读毛选、我的奋斗等，上油管看看青年大学习，玩玩eu4、红警、pvz之类的；</p><p>今天一看炼丹云，欠费一百多，已经是崩了。不过没事后面不用了。然后感觉就是这个</p><h2 id="2-规划"><a href="#2-规划" class="headerlink" title="2 规划"></a>2 规划</h2><p>总体要完成的几个项目：</p><p>1.zhipinkkclub</p><p>2.timerme</p><p>3.bbs</p><p>4.留下想像空间的项目，可以是自研轮子或者自研游戏。暂不安排</p><p>建议划分为四个阶段，</p><p>七月上旬：短学期+恢复日常学习状态（（看课如b站、淘宝、抖音等平台的）、力扣（3&#x2F;day）、八股）+看书）</p><p>七月中旬：</p><p>回到家里，整理一下书房，先开始学CN，然后着手做BBS和TIMERME，注意可以有合理的任务分配。日常的学习状态保持，然后也保持阅读书籍。k8s。grpc。</p><p>七月下旬：</p><p>CN收尾、OS开始、日常、阅读、TIMERME收尾，zhipinkkclub完成。</p><p>八月上旬：</p><p>OS收尾、计组开始、日常（包括阅读）、bbs</p><p>八月中旬：</p><p>计组、日常、BBS+zhipinkk体系基本完善、认真收尾八股，开始投简历。</p><p>八月下旬：</p><p>短学期、日常 、八股、计组。</p><h2 id="3-电子管-晶体管-与-或-加法器-ALU"><a href="#3-电子管-晶体管-与-或-加法器-ALU" class="headerlink" title="3 电子管-&gt;晶体管-&gt;与-&gt;或-&gt;加法器-&gt;ALU"></a>3 电子管-&gt;晶体管-&gt;与-&gt;或-&gt;加法器-&gt;ALU</h2><p>电子管原理<a href="https://www.bilibili.com/video/BV1Pu411N74Q/?spm_id_from=333.337.search-card.all.click&vd_source=ef22f225254902b1a7226d19e89d6cde">https://www.bilibili.com/video/BV1Pu411N74Q/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ef22f225254902b1a7226d19e89d6cde</a></p><p>在学习知识的时候，如果有不懂得地方，会呈现两种状态，一种是知道多看几遍可以搞懂的，一种是感觉比较难理解的，后者往往可能是缺了某块知识，这种时候跳过是最好的，回头再看就会很快，否则会浪费时间。</p><p>这个世界很神奇，为什么刚好有电这种东西存在呢？</p><p>与逻辑实现：</p><p><a href="https://www.bilibili.com/video/BV1Ti4y1e71G/?spm_id_from=333.337.search-card.all.click&vd_source=ef22f225254902b1a7226d19e89d6cde">https://www.bilibili.com/video/BV1Ti4y1e71G/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ef22f225254902b1a7226d19e89d6cde</a></p><h2 id="4-effective-java-静态工厂方法替代构造方法"><a href="#4-effective-java-静态工厂方法替代构造方法" class="headerlink" title="4 effective java:静态工厂方法替代构造方法"></a>4 effective java:静态工厂方法替代构造方法</h2><p>简单来说，对象的实例不用去new，而是自定义的创建对象函数，然后注意这玩意是静态的，静态的代表不需要对象实例就可以被调用。而构造函数将会被私有化。优点是意图明确，然后内存的控制更灵活。缺点在于难在API文档中标识出来构造应该通过静态工厂方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部直接使用new来创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Vehicle</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法，提供了更明确的命名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vehicle <span class="title function_">createCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="string">&quot;Car&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vehicle <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="string">&quot;Bike&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用静态工厂方法创建对象</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">car</span> <span class="operator">=</span> Vehicle.createCar();</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">bike</span> <span class="operator">=</span> Vehicle.createBike();</span><br><span class="line"></span><br><span class="line">        System.out.println(car.getType());  <span class="comment">// 输出：Car</span></span><br><span class="line">        System.out.println(bike.getType()); <span class="comment">// 输出：Bike</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-effective-java：构造器替代多参数构造函数"><a href="#5-effective-java：构造器替代多参数构造函数" class="headerlink" title="5 effective java：构造器替代多参数构造函数"></a>5 effective java：构造器替代多参数构造函数</h2><p><img src="/.top//Users\11953\AppData\Roaming\Typora\typora-user-images\image-20240711012617675.png" alt="image-20240711012617675"></p><p>如图展示一个构造器，也就是常说的builder。</p><p>首先明确概念<strong>抽象类</strong>：不能被实例化的类。</p><p><strong>抽象方法</strong>：没有方法体的方法。</p><p>然后如果添加一些枚举可以让代码可读性更高：</p><p><img src="/.top//Users\11953\AppData\Roaming\Typora\typora-user-images\image-20240711020315176.png" alt="image-20240711020315176"></p><h2 id="6-effective-java：-Singleton的优化"><a href="#6-effective-java：-Singleton的优化" class="headerlink" title="6 effective java： Singleton的优化"></a>6 effective java： Singleton的优化</h2><p>Singleton：单例模式，即只有一个实例。</p><p>私有构造器：确保只实例化一次，但是一开始就全局实例化，可能出现没有用也有实例的情况</p><p><img src="/.top//Users\11953\AppData\Roaming\Typora\typora-user-images\image-20240711102704908.png" alt="image-20240711102704908"></p><p>枚举单例：枚举机制可以防止被多次实例化。</p><p><img src="/.top//Users\11953\AppData\Roaming\Typora\typora-user-images\image-20240711102811875.png" alt="image-20240711102811875"></p><h2 id="7-EJ：私有构造器防止类被实例化"><a href="#7-EJ：私有构造器防止类被实例化" class="headerlink" title="7 EJ：私有构造器防止类被实例化"></a>7 EJ：私有构造器防止类被实例化</h2><p>私有的构造函数并且抛异常，很好杜绝一个类似于枚举类型的类被实例化。</p><p><img src="/.top//Users\11953\AppData\Roaming\Typora\typora-user-images\image-20240711103524305.png" alt="image-20240711103524305"></p><p>缺点是不能继承（子类化），因为没有构造函数，子类必须调用超类构造器。</p><p><img src="/.top//Users\11953\AppData\Roaming\Typora\typora-user-images\image-20240711103708618.png" alt="image-20240711103708618"></p><h2 id="8-了解依赖注入与JAVA8的Supplier接口"><a href="#8-了解依赖注入与JAVA8的Supplier接口" class="headerlink" title="8 了解依赖注入与JAVA8的Supplier接口"></a>8 了解依赖注入与JAVA8的Supplier接口</h2><h3 id="示例：不使用依赖注入"><a href="#示例：不使用依赖注入" class="headerlink" title="示例：不使用依赖注入"></a>示例：不使用依赖注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String recipient)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String recipient)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending an email to &quot;</span> + recipient + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;  <span class="comment">// 直接依赖具体实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Application</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emailService = <span class="keyword">new</span> <span class="title class_">EmailService</span>();  <span class="comment">// 实例化具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processMessages</span><span class="params">(String message, String recipient)</span> &#123;</span><br><span class="line">        emailService.sendMessage(message, recipient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>();</span><br><span class="line">        app.processMessages(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;user@example.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例：使用依赖注入"><a href="#示例：使用依赖注入" class="headerlink" title="示例：使用依赖注入"></a>示例：使用依赖注入</h3><p>其他不变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;  <span class="comment">// 依赖抽象接口，而不是具体实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Application</span><span class="params">(MessageService service)</span> &#123;  <span class="comment">// 通过构造函数注入依赖</span></span><br><span class="line">        <span class="built_in">this</span>.messageService = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processMessages</span><span class="params">(String message, String recipient)</span> &#123;</span><br><span class="line">        messageService.sendMessage(message, recipient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmailService</span>();  <span class="comment">// 创建依赖对象</span></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(service);  <span class="comment">// 注入依赖</span></span><br><span class="line">        app.processMessages(<span class="string">&quot;Hello, Dependency Injection&quot;</span>, <span class="string">&quot;user@example.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><p>主要区别在于，一个是依赖接口，一个是依赖具体实现类。显然前者灵活性更好。</p><h3 id="Supplier接口的定义"><a href="#Supplier接口的定义" class="headerlink" title="Supplier接口的定义"></a>Supplier接口的定义</h3><p><code>Supplier&lt;T&gt;</code> 接口定义非常简单，它包含一个没有输入参数的方法 <code>get()</code>，该方法返回一个泛型 <code>T</code> 类型的结果。这里的 <code>T</code> 是输出类型，由实现此接口的类来指定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><code>Supplier</code> 接口通常用于延迟生成或计算值，或者在需要生成一个新对象而不需要额外信息时使用。例如，它可以用于提供默认值或者构造复杂对象。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个使用 <code>Supplier</code> 接口的简单示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SupplierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Lambda表达式创建Supplier实例</span></span><br><span class="line">        Supplier&lt;String&gt; stringSupplier = () -&gt; <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用get()方法获取值</span></span><br><span class="line">        System.out.println(stringSupplier.get()); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个更复杂的对象</span></span><br><span class="line">        Supplier&lt;LocalDateTime&gt; timeSupplier = () -&gt; LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;Current time: &quot;</span> + timeSupplier.get()); <span class="comment">// 输出当前时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>Supplier</code> 接口来改造工厂模式是一个现代化和更具灵活性的方法。这种方式允许我们使用 Java 8 引入的函数式编程特性，让代码更加简洁和可扩展。下面我将示范如何使用 <code>Supplier</code> 接口来改造之前的数据库连接工厂。</p><h3 id="能否展现一个资源工厂传递给构造器的设计方法？"><a href="#能否展现一个资源工厂传递给构造器的设计方法？" class="headerlink" title="能否展现一个资源工厂传递给构造器的设计方法？"></a>能否展现一个资源工厂传递给构造器的设计方法？</h3><p>在设计模式中，资源工厂的概念通常与依赖注入（DI）结合使用，特别是在构造器注入的情况下。这种模式不仅有助于降低组件之间的耦合，还提高了代码的灵活性和可测试性。</p><p>假设我们有一个应用程序需要连接到多种数据库（如MySQL、PostgreSQL等），我们可以创建一个数据库连接工厂，这个工厂根据配置或需求动态创建相应的数据库连接。</p><h3 id="步骤-1-定义数据库连接接口"><a href="#步骤-1-定义数据库连接接口" class="headerlink" title="步骤 1: 定义数据库连接接口"></a>步骤 1: 定义数据库连接接口</h3><p>首先，我们定义一个数据库连接的接口，这个接口规定了所有数据库连接必须实现的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2-实现具体的数据库连接类"><a href="#步骤-2-实现具体的数据库连接类" class="headerlink" title="步骤 2: 实现具体的数据库连接类"></a>步骤 2: 实现具体的数据库连接类</h3><p>接下来，我们实现几个具体的数据库连接类，每个类对应一种数据库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLConnection</span> <span class="keyword">implements</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connecting to MySQL database.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Disconnecting from MySQL database.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostgreSQLConnection</span> <span class="keyword">implements</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connecting to PostgreSQL database.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Disconnecting from PostgreSQL database.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，<code>Supplier</code> 是一个功能接口（functional interface），主要用于提供一个数据值，而不接受任何参数。它属于 <code>java.util.function</code> 包，这个包包含了多种功能接口，用于支持Java的Lambda表达式和函数式编程。</p><h3 id="步骤-3-使用-Supplier-改造工厂"><a href="#步骤-3-使用-Supplier-改造工厂" class="headerlink" title="步骤 3: 使用 Supplier 改造工厂"></a>步骤 3: 使用 <code>Supplier</code> 改造工厂</h3><p>这次我们使用 <code>Supplier&lt;DatabaseConnection&gt;</code> 来改造工厂方法，使其返回一个 <code>Supplier</code> 实例，而不是直接返回一个数据库连接对象。这种方式让我们能够延迟连接的创建直到真正需要时。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Supplier&lt;DatabaseConnection&gt;&gt; connectionSuppliers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        connectionSuppliers.put(<span class="string">&quot;MySQL&quot;</span>, MySQLConnection::<span class="keyword">new</span>);</span><br><span class="line">        connectionSuppliers.put(<span class="string">&quot;PostgreSQL&quot;</span>, PostgreSQLConnection::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Supplier&lt;DatabaseConnection&gt; <span class="title function_">getConnectionSupplier</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Supplier&lt;DatabaseConnection&gt; supplier = connectionSuppliers.get(type);</span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No such database type supported.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> supplier;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4-使用构造器注入-Supplier"><a href="#步骤-4-使用构造器注入-Supplier" class="headerlink" title="步骤 4: 使用构造器注入 Supplier"></a>步骤 4: 使用构造器注入 <code>Supplier</code></h3><p>现在我们修改 <code>DataManager</code> 类，使其接收一个 <code>Supplier&lt;DatabaseConnection&gt;</code>。这允许 <code>DataManager</code> 控制连接的实际创建时机。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;DatabaseConnection&gt; connectionSupplier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataManager</span><span class="params">(Supplier&lt;DatabaseConnection&gt; connectionSupplier)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionSupplier = connectionSupplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DatabaseConnection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionSupplier.get(); <span class="comment">// 实际创建连接</span></span><br><span class="line">        connection.connect();</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing data...&quot;</span>);</span><br><span class="line">        connection.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5-在应用中使用"><a href="#步骤-5-在应用中使用" class="headerlink" title="步骤 5: 在应用中使用"></a>步骤 5: 在应用中使用</h3><p>我们使用改造后的工厂来获取连接的 <code>Supplier</code> 并传递给 <code>DataManager</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;DatabaseConnection&gt; connectionSupplier = DatabaseConnectionFactory.getConnectionSupplier(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        <span class="type">DataManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManager</span>(connectionSupplier);</span><br><span class="line">        manager.processData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类似于一种分发装置。</p><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p>高手总是会把一个非常有讲究的事情描述的非常轻松，首先一点是他的精神状态确实比较轻松，其次他们懒得给对他们毫无利益的外人总结自己独门的解决方案。比如高绩点他会说期末学个两周，平时代签就可以。殊不知平时的精神状态、作息、预备知识等都是非常重要的因素，也不能保证他之前没有在其他地方学过。因此我们如果想要复刻高手的逻辑，就要复刻他们隐藏的一些点，而不是只见表面。比如说，可以平日里非常努力地做其他事情而不是摆烂，然后作息要正常，心态要好，同时可以超前学习某些科目，然后隔一段时间反复速成，也会得到很好的巩固。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>有的时候会发现，有事情的时候感觉来不及学了，就想开摆，而开摆的时候又感觉没那么明显来不及学的感觉。不过这只是一种自我欺骗，面对焦虑，不应该去逃避，而是直接硬钢，让自己行动起来，而不是逃走。因为前者对自己长期收益更大，而后者“得一夕安寝，而秦兵又至矣”。</p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>知识都是前人写好的，他们往往不是什么世界的真理，而是认为的规定，我们要做的就是学别人的规定罢了。 </p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p>有时候发现自己没有那么强的欲望和目标感，这是因为对太多东西祛魅了，往往就丧失了向上的动力。适当赋魅其实是必要的，如果一些奖、成绩、论文我们看做是垃圾，但是一些重要的岗位、考到好的院校却可以当做我们宏伟的目标。没有志向的人终究会堕落。</p><p>祛魅这个东西再说，比如游戏为什么上瘾，因为游戏打得好，排名高，会让人觉得有面子，也会得到一些崇拜。但是大了之后，就发现没人崇拜了，也没人在意这个游戏，它的含金量失去了，只是自娱自乐，因此也就没意思了。现仅存的就是一些虚幻的征服感。人越趋向于理解事物的本质，就越会痛失幻想的能力。突然发现中学时期我所诟病的梦想家其实是一个伟大的能力，而我却逐渐遗失了它，包括遗失了对恋爱之流的幻想。情绪稳定也许是有好处，但是随之带来的是也没有特别令人兴奋的时刻。幻想不得不说是一项伟大的能力，还有那种不服输的野性也是。所谓的情绪稳定，往坏了说就是丧失了征服的野性，也失去了对梦想的渴望，未老先衰，不是好事。贪婪的人才能得到更多，这是人性的本质，但是隐藏是一门艺术。我要推翻一直以来“真实”的信念，因为我觉得真实才能轻松不容易露馅，但现在看来，去弄虚作假而瞒天过海，才是更高深的一门学问。当然，这里的弄虚作假我不希望是学术、技术等，而是人际关系方面。在前者方面上，我还是认为以“真”为本才好，毕竟杀人造了把假刀，也杀不死人。但是在人际上，却可以靠撒谎实现借刀杀人。这就是物理层面和精神层面的差距。</p><h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><p>是什么人能够脱颖而出？明知道需要自律但是真正能自律的人。对一些事情真正热爱并且去做的人。前人归结作几个词：致良知、知行合一。</p><p>有的知识，一下子理解不了，不需要死磕，因为自己的储备还没有到那个level，只需要耐心地继续储备，回头顺其自然地就解决了。如果患得患失，或者对无生命事物动怒，无异于原始人。</p><p>让自己变成被迫学习的人，然后完成一些任务之后就可以获得一些奖励，这样会很欢乐。把自己当成一个小孩，然后用理性人建立奖励机制，这应该是一种不错的学习办法。</p><p>人就应该建立多重人格，不然又怎么去了解世界上那么多性格？每多一种人格就多一种对他人的了解。而不同的人格还可以帮助自己认识自我，找到一个适合于自己当下的人格，然后逐渐让他们相互借鉴融合。</p><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p>感觉学习工作无聊的时候，就让自己发呆放空，而不是找事情消遣。放空会让自己变得更无聊，从而会觉得学习工作稍微会有趣一点。这是利用人性本来的规律。</p><h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p>我必考研，干嘛不考？考的好处：</p><p>1.考上了有光环title，更有自尊，更好找工作</p><p>2.有更好的平台资源和人脉</p><p>3.去大城市见识一下</p><p>4.有更多时间去学习，去修炼，去深造，有更多未知的可能，更能和先进技术接轨</p><p>5.好找对象，不仅是院校上的，还有title上的</p><p>不考的好处：</p><p>1.早点工作，提早步入成年人生活</p><p>2.大学期间腾出更多时间投入开发和自己的项目</p><p>玛德总的来说肯定长远看是考研好，对不。冲。</p><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p>滞后性，不仅是审美、大众追求，还有价值观的对齐。</p><p>比如学历贬值，但是仍然有它很有用的刻板印象；</p><p>海归、好工作、好专业、发论文；</p><p>门槛一旦降低，那么价值就降低。</p><h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p>天才都不适合婚姻。</p><p>哲学和文学到底是不是一体两面呢？他们好像是交织在一起的。</p><p>我现在在从绩优主义向幸福注意、犬儒主义和荒诞主义转变。</p><p>人不应该对着自己的弱点期待被怜悯和安慰，而是去除这些弱点。</p><p>人类的进步靠的不是合群的人，而是逆天的人。</p><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p>今天刷20道力扣。总结一些细节小点，作为备忘录</p><p>1.异或公式</p><p><img src="/.top//Users\11953\AppData\Roaming\Typora\typora-user-images\image-20240722180750670.png" alt="image-20240722180750670"></p><p><img src="/.top//Users\11953\AppData\Roaming\Typora\typora-user-images\image-20240722180800750.png" alt="image-20240722180800750"></p><p>2.<code>StringBuilder</code>是一个<code>final</code>类，因此不能通过继承匿名内部类来扩展它。</p>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <category domain="https://cjliblog.top/tags/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <comments>https://cjliblog.top/2024/07/06/24-7-6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang学习笔记</title>
      <link>https://cjliblog.top/2024/07/06/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>https://cjliblog.top/2024/07/06/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Fri, 05 Jul 2024 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;golang基础&quot;&gt;&lt;a href=&quot;#golang基础&quot; class=&quot;headerlink&quot; title=&quot;golang基础&quot;&gt;&lt;/a&gt;golang基础&lt;/h1&gt;&lt;h2 id=&quot;1-unsafe包解读&quot;&gt;&lt;a href=&quot;#1-unsafe包解读&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="golang基础"><a href="#golang基础" class="headerlink" title="golang基础"></a>golang基础</h1><h2 id="1-unsafe包解读"><a href="#1-unsafe包解读" class="headerlink" title="1.unsafe包解读"></a>1.unsafe包解读</h2><p>绕过安全规则的方法，比如获取内存信息的sizeof方法。</p><p>unsafe包应当主要用于程序员调试，而不能出现在生产应用。</p><h2 id="2-获得字符串的指针"><a href="#2-获得字符串的指针" class="headerlink" title="2.获得字符串的指针"></a>2.获得字符串的指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sh :=(*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br></pre></td></tr></table></figure><p>s是字符串，由于字符串的runtime底层包是私有法方法，但是reflect里面有StringHeader方法作为public的映射，因此先强转成指针，然后再强转成StringHeader。注意，这个过程中地址不会发生改变。</p><p>其中，包含一个Data指针（原始的int）和一个Len（int）。</p><p><img src="https://m.qpic.cn/psc?/V53kfs7M0yNvo22mPmRx0m705V1QyDz1/TmEUgtj9EK6.7V8ajmQrEMD*9Zg.P8RU7ZvFcGgmLScgtg7eIeJxpZY6*AJ*VSCcTgMqP0G75RabbEJ7ZMY15lPODWpyCc1KQki*7ql*Tzs!/b&bo=mgLTAAAAAAABB2s!&rf=viewer_4" alt="img"></p><h2 id="3-rune类型是什么？"><a href="#3-rune类型是什么？" class="headerlink" title="3.rune类型是什么？"></a>3.rune类型是什么？</h2><p>可以理解成utf8的类型。因为不管是一个汉字还是一个字母，都是一个单位的rune。因此它还和传统意义上的char有所区别。它是int32类型，也就是说是int（64）的一半。</p><h2 id="4-切片"><a href="#4-切片" class="headerlink" title="4.切片"></a>4.切片</h2><p>个人感觉go的切片相当于java中的arraylist，进行一个主动开辟空间，然后动态扩容的自动化操作。</p><p>那么关于容量调整，其实arraylist和slice都是默认扩大，而不会缩小，除非把它释放。</p><p>还有一个点就是slice可以由数组创建，因为它的底层cap是数组结构，因此可能产生slice在cap里的偏移，比如从下标为3开始，而arraylist一定是在cap（容量）里顶格的，除非做一些复杂的底层操作。</p><p>arraylist的扩容是初始为10，每次1.5倍。而slice的扩容是每次两倍（当len&gt;1024，每次增加25%）。</p><p>这二者都线程不安全。原因在于：扩容的时候废弃原来的地址，导致其他协程（线程）会发生错误。</p><h2 id="5-哈希"><a href="#5-哈希" class="headerlink" title="5.哈希"></a>5.哈希</h2><p>java和go的hashmap（go就是map）都采用链式寻址。一个地址一条链，叫做桶。go的桶里面包括一个bmap数组（$2^B$个单位，B来自结构体的字段），有一个nextoverflow字段，指向链表中的下一个桶。一个bmap可以放bucketCnt个键值对，bucketCnt默认值为8，里面放tophash、key、elem（value）、overflow（若溢出指针）等。</p><h4 id="关于扩容："><a href="#关于扩容：" class="headerlink" title="关于扩容："></a>关于扩容：</h4><p>当负载因子 $load factor&#x3D;\frac{elemNum}{bucketNum}&gt;6.5$ 或溢出桶数量过多时会开辟新桶，届时采用渐进式（incremental）扩容，即老的桶依然存在并保存在对象的oldBucket字段，当每次操作map（插入或删除）之后会迁移一定量的桶，直到全部完成，然后对老桶数组进行垃圾回收。</p><p>也正因为渐进式扩容，因此线程也不安全，因此有必要加互斥锁（mutex）。</p><h4 id="关于Sync-Map"><a href="#关于Sync-Map" class="headerlink" title="关于Sync.Map"></a>关于Sync.Map</h4><p>由于扩容的线程不安全，衍生出官方的数据结构——Sync包下的Map。</p><p>该结构有四个字段：mu，read，dirty和missed。</p><p>主要分成两线存key，分为read和dirty两种存储结构，而value共用一份内存，适用于读多写少的情况。</p><p>查、改：一般情况读走read（一个只读快照），若read中找不到，锁住mu，走dirty。</p><p>追加：添加数据走dirty（写时才发生read的复制并追加），而在读read会有未命中次数累加到missed字段，missed达到len(dirty)的时候，将发生《dirty上移》，也就是把read指针指向dirty，dirty指针指向nil。</p><p>删除：直接让read的某个key指向nil。如果是dirty中的追加键（read中找不到的key）被删除，则上提成read时给nil改成expunged，用于标记下一次复制到新dirty时不再考虑这个key。</p>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <category domain="https://cjliblog.top/tags/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <comments>https://cjliblog.top/2024/07/06/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>大注释实时模版</title>
      <link>https://cjliblog.top/2024/06/09/%E5%A4%A7%E6%B3%A8%E9%87%8A%E5%AE%9E%E6%97%B6%E6%A8%A1%E7%89%88/</link>
      <guid>https://cjliblog.top/2024/06/09/%E5%A4%A7%E6%B3%A8%E9%87%8A%E5%AE%9E%E6%97%B6%E6%A8%A1%E7%89%88/</guid>
      <pubDate>Sat, 08 Jun 2024 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;[&lt;img src=&quot;https://raw.githubusercontent.com/Li-can-cheng/Li-can-cheng.github.io/main/img/%E5%A4%A7%E6%B3%A8%E9%87%8A%E5%AE%9E</description>
        
      
      
      
      <content:encoded><![CDATA[<p>如图：</p><p>[<img src="https://raw.githubusercontent.com/Li-can-cheng/Li-can-cheng.github.io/main/img/%E5%A4%A7%E6%B3%A8%E9%87%8A%E5%AE%9E%E6%97%B6%E6%A8%A1%E7%89%88.jpg" alt="大注释实时模版">]</p>]]></content:encoded>
      
      
      <category domain="https://cjliblog.top/categories/%E8%84%9A%E6%9C%AC/">脚本</category>
      
      
      
      <comments>https://cjliblog.top/2024/06/09/%E5%A4%A7%E6%B3%A8%E9%87%8A%E5%AE%9E%E6%97%B6%E6%A8%A1%E7%89%88/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
